[
  {
    "tags": [
      {
        "type": "class",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{Object|Array|Number|String|Function} data",
        "name": "data",
        "description": "",
        "types": [
          "Object",
          "Array",
          "Number",
          "String",
          "Function"
        ],
        "typesDescription": "<code>Object</code>|<code>Array</code>|<code>Number</code>|<code>String</code>|<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Object|Array|Number|String|Function} data</p>"
      },
      {
        "type": "param",
        "string": "{Function} check",
        "name": "check",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} check</p>"
      }
    ],
    "description": {
      "full": "<p>Abstract element</p>",
      "summary": "<p>Abstract element</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": true,
    "isEvent": false,
    "ignore": true,
    "line": 2,
    "codeStart": 11,
    "code": "function Element (data, check) {\n  if (typeof data === 'undefined')\n    throw new TypeError('Undefined data')\n\n  if (check(data))\n    this.data = data\n  else\n    throw new TypeError('Invalid data = ', data)\n}",
    "ctx": {
      "type": "function",
      "name": "Element",
      "string": "Element()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 21,
    "codeStart": 24,
    "code": "function valueOf () {\n  return this.data\n}\n\nElement.prototype.valueOf = valueOf\n\nmodule.exports = Element\n\n\nvar inherits = require('inherits')\n\nvar determinant               = require('./determinant'),\n    getIndices                = require('./getIndices'),\n    matrixToArrayIndex        = require('./matrixToArrayIndex'),\n    rowByColumnMultiplication = require('./rowByColumnMultiplication.js'),\n    toData                    = require('./toData'),\n    VectorSpace               = require('./VectorSpace')",
    "ctx": {
      "type": "function",
      "name": "valueOf",
      "string": "valueOf()"
    }
  },
  {
    "tags": [
      {
        "type": "class",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{Object} Scalar",
        "name": "Scalar",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Object} Scalar</p>"
      },
      {
        "type": "param",
        "string": "{Number} numRows",
        "name": "numRows",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Number} numRows</p>"
      },
      {
        "type": "param",
        "string": "{Number} numCols",
        "name": "numCols",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Number} numCols</p>"
      }
    ],
    "description": {
      "full": "<p>Space of m x n matrices</p>",
      "summary": "<p>Space of m x n matrices</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": true,
    "isEvent": false,
    "ignore": false,
    "line": 42,
    "codeStart": 52,
    "code": "function MatrixSpace (Scalar) {",
    "ctx": {
      "type": "function",
      "name": "MatrixSpace",
      "string": "MatrixSpace()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Number} numRows",
        "name": "numRows",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Number} numRows</p>"
      },
      {
        "type": "param",
        "string": "{Number} numCols which is optional: defaults to a square matrix.\n",
        "name": "numCols",
        "description": "<p>which is optional: defaults to a square matrix. </p>",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Constructor} Matrix",
        "types": [
          "Constructor"
        ],
        "typesDescription": "<a href=\"Constructor.html\">Constructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>Matrix</p>"
      }
    ],
    "description": {
      "full": "<p>Dimension</p>",
      "summary": "<p>Dimension</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 53,
    "codeStart": 62,
    "code": "function Dimension (numRows, numCols) {\n  var isSquare = false\n\n  if (typeof numCols === 'undefined') {\n    // numCols defaults to numRows\n    numCols = numRows\n\n    isSquare = true\n  }\n\n  var indices = [numRows, numCols]\n\n  var Element = Space(Scalar)(indices)",
    "ctx": {
      "type": "function",
      "name": "Dimension",
      "string": "Dimension()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 76,
    "codeStart": 80,
    "code": "function Matrix () {\n  Element.apply(this, arguments)",
    "ctx": {
      "type": "function",
      "name": "Matrix",
      "string": "Matrix()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 83,
    "codeStart": 87,
    "code": "function matrixDeterminant () {\n  var det = determinant(Scalar, this.data, numRows)\n\n  return new Scalar(det)\n}\n\nif (isSquare) {\n  Object.defineProperty(this, 'determinant', {get: matrixDeterminant})\n  Object.defineProperty(this, 'det', {get: matrixDeterminant})\n}\n    }\n\n    inherits(Matrix, Element)\n\n    // Static attributes.\n    Matrix.isSquare = isSquare\n    Matrix.numRows  = numRows\n    Matrix.numCols  = numCols\n\n    // Static operators.\n    Matrix.addition    = Element.addition\n    Matrix.add         = Element.addition\n    Matrix.subtraction = Element.subtraction\n    Matrix.sub         = Element.subtraction",
    "ctx": {
      "type": "function",
      "name": "matrixDeterminant",
      "string": "matrixDeterminant()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 112,
    "codeStart": 116,
    "code": "function matrixAddition (matrix) {\n  this.data = Element.addition(this.data, matrix)\n\n  return this\n}\n\nMatrix.prototype.addition = matrixAddition\nMatrix.prototype.add      = matrixAddition",
    "ctx": {
      "type": "function",
      "name": "matrixAddition",
      "string": "matrixAddition()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 125,
    "codeStart": 129,
    "code": "function matrixSubtraction (matrix) {\n  this.data = Element.subtraction(this.data, matrix)\n\n  return this\n}\n\nMatrix.prototype.subtraction = matrixSubtraction\nMatrix.prototype.sub         = matrixSubtraction",
    "ctx": {
      "type": "function",
      "name": "matrixSubtraction",
      "string": "matrixSubtraction()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 138,
    "codeStart": 142,
    "code": "function rightMultiplication (right) {\n  var rightData    = toData(right),\n      rightIndices = getIndices(right)\n\n  var rightIsMatrix = rightIndices.length === 2,\n      rightIsVector = rightIndices.length === 1\n\n  // TODO rightIsScalar and use scalarMultiplication\n\n  var rightIsSquare = rightIsMatrix && (rightIndices[0] === rightIndices[1])\n\n  if (rightIsVector)\n    rightIndices.push(1)\n\n  var data = rowByColumnMultiplication(Scalar, this.data, this.indices, rightData, rightIndices)\n\n  // Left multiplication by a square matrix is an internal operation,\n  // so the method is a mutator.\n  if (rightIsSquare) {\n    this.data = data\n\n    return this\n  }\n\n  if (rightIsVector) {\n    var Vector = VectorSpace(Scalar)(numRows)\n\n    return new Vector(data)\n  }\n    // TODO if rightIsMatrix return new this(Scalar)(numRows, numCols)(data)\n}\n\nMatrix.prototype.rightMultiplication = rightMultiplication\nMatrix.prototype.rightMul            = rightMultiplication\nMatrix.prototype.multiplication      = rightMultiplication\nMatrix.prototype.mul                 = rightMultiplication",
    "ctx": {
      "type": "function",
      "name": "rightMultiplication",
      "string": "rightMultiplication()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 179,
    "codeStart": 183,
    "code": "function leftMultiplication (leftMatrix) {\n  var leftData    = toData(left),\n      leftIndices = getIndices(left)\n\n  var leftIsMatrix = leftIndices.length === 2,\n      leftIsVector = leftIndices.length === 1\n\n  var leftIsSquare = leftIsMatrix && (leftIndices[0] === leftIndices[1])\n\n  if (leftIsVector)\n    leftIndices.push(1)\n\n  var data = rowByColumnMultiplication(Scalar, leftData, leftIndices, this.data, this.indices)\n\n  // Left multiplication by a square matrix is an inner product,\n  // so the method is a mutator.\n  if (leftIsSquare) {\n    this.data = data\n\n    return this\n  }\n\n  if (leftIsVector) {\n    var Vector = VectorSpace(Scalar)(numCols)\n\n    return new Vector(data)\n  }\n}\n\nMatrix.prototype.leftMultiplication = leftMultiplication\nMatrix.prototype.leftMul            = leftMultiplication",
    "ctx": {
      "type": "function",
      "name": "leftMultiplication",
      "string": "leftMultiplication()"
    }
  },
  {
    "tags": [
      {
        "type": "todo",
        "string": "should be extended to a Tensor operator, also vectors can be transposed ",
        "html": "<p>should be extended to a Tensor operator, also vectors can be transposed </p>"
      },
      {
        "type": "param",
        "string": "{numRows}",
        "name": "",
        "description": "",
        "types": [
          "numRows"
        ],
        "typesDescription": "<a href=\"numRows.html\">numRows</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{numRows}</p>"
      },
      {
        "type": "param",
        "string": "{numCols}",
        "name": "",
        "description": "",
        "types": [
          "numCols"
        ],
        "typesDescription": "<a href=\"numCols.html\">numCols</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{numCols}</p>"
      },
      {
        "type": "param",
        "string": "{Object|Array} matrix\n",
        "name": "matrix",
        "description": "",
        "types": [
          "Object",
          "Array"
        ],
        "typesDescription": "<code>Object</code>|<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Object|Array} matrix</p>"
      },
      {
        "type": "returns",
        "string": "{Array} transposedData",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>transposedData</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 215,
    "codeStart": 225,
    "code": "function transpose (numRows, numCols, matrix) {\n  var data = toData(matrix),\n      transposedData = []\n\n  for (var i = 0; i < numRows; i++)\n    for (var j = 0; j < numCols; j++)\n      transposedData.push(data[matrixToArrayIndex(j, i, numCols)])\n\n  return transposedData\n}\n\nvar staticTranspose = transpose.bind(null, numRows, numCols)\nMatrix.transpose = staticTranspose\nMatrix.tr            = staticTranspose",
    "ctx": {
      "type": "function",
      "name": "transpose",
      "string": "transpose()"
    }
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "{Object} transposedMatrix",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>transposedMatrix</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 240,
    "codeStart": 245,
    "code": "function matrixTransposition () {\n  var data    = this.data,\n      numCols = this.numCols,\n      numRows = this.numRows\n\n  var transposedData     = transpose(numCols, numRows, data),\n      transposedIndices  = [numCols, numRows]\n\n  var TransposedMatrix = Space(Scalar)(transposedIndices)\n\n  var transposedMatrix = new TransposedMatrix(transposedData)\n\n  return transposedMatrix\n}\n\nMatrix.prototype.transpose = matrixTransposition\nMatrix.prototype.tr        = matrixTransposition\nMatrix.prototype.t         = matrixTransposition\n\nreturn Matrix\n  }\n\n  return Dimension\n}\n\nmodule.exports = MatrixSpace\n\n\nvar ring = require('./ring')\n\nvar Real = ring([0, 1], {\n  contains:       function (a, b) {\n                // NaN, Infinity and -Infinity are not allowed\n                return (typeof a === 'number' && isFinite(a))\n              },\n  equality:       function (a, b) { return a === b },\n  addition:       function (a, b) { return a + b },\n  negation:       function (a) { return -a },\n  multiplication: function (a, b) { return a * b },\n  inversion:      function (a) { return 1 / a }\n})\n\nmodule.exports = Real\n\n\nvar getIndices                = require('./getIndices'),\ngroup                     = require('./group'),\ninherits                  = require('inherits'),\nrowByColumnMultiplication = require('./rowByColumnMultiplication.js'),\ntoData                    = require('./toData')",
    "ctx": {
      "type": "function",
      "name": "matrixTransposition",
      "string": "matrixTransposition()"
    }
  },
  {
    "tags": [
      {
        "type": "function",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{Object} Scalar class\n",
        "name": "Scalar",
        "description": "<p>class </p>",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Function} anonymous with signature (dimension)",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>anonymous with signature (dimension)</p>"
      }
    ],
    "description": {
      "full": "<p>Space of vectors</p><pre><code>var V = VectorSpace(R)(2)\n\nvar v = new V([1, 2])\n</code></pre>",
      "summary": "<p>Space of vectors</p>",
      "body": "<pre><code>var V = VectorSpace(R)(2)\n\nvar v = new V([1, 2])\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 296,
    "codeStart": 312,
    "code": "function VectorSpace (Scalar) {",
    "ctx": {
      "type": "function",
      "name": "VectorSpace",
      "string": "VectorSpace()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Number} dimension\n",
        "name": "dimension",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Number} dimension</p>"
      },
      {
        "type": "returns",
        "string": "{Constructor} Vector",
        "types": [
          "Constructor"
        ],
        "typesDescription": "<a href=\"Constructor.html\">Constructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>Vector</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 314,
    "codeStart": 321,
    "code": "return function (dimension) {\n\n  function createZero (scalarZero, dimension) {\n    var vectorZero = []\n\n    for (var i = 0; i < dimension; i++)\n      vectorZero.push(scalarZero)\n\n   return vectorZero\n  }\n\n  var zero = createZero(Scalar.zero, dimension)\n\n  function contains (a) {\n    if (a.length !== dimension) return false\n\n    for (var i = 0; i < dimension; i++)\n      if (! Scalar.contains(a[i]))\n        return false\n\n    return true\n  }\n\n  function equality (a, b) {\n    for (var i = 0; i < dimension; i++)\n      if (! Scalar.equality(a[i], b[i]))\n        return false\n\n    return true\n  }\n\n  function addition (a, b) {\n    var c = []\n\n    for (var i = 0; i < dimension; i++)\n      c.push(Scalar.addition(a[i], b[i]))\n\n    return c\n  }\n\n  function negation (a) {\n    var b = []\n\n    for (var i = 0; i < dimension; i++)\n      b.push(Scalar.negation(a[i]))\n\n    return b\n  }\n\n  var Group = group({\n    identity       : zero,\n    contains       : contains,\n    equality       : equality,\n    compositionLaw : addition,\n    inversion      : negation\n  })",
    "ctx": {
      "type": "function",
      "name": "",
      "string": "()"
    }
  },
  {
    "tags": [
      {
        "type": "class",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{*} data",
        "name": "data",
        "description": "",
        "types": [],
        "typesDescription": "<code>*</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{*} data</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": true,
    "isEvent": false,
    "ignore": false,
    "line": 378,
    "codeStart": 385,
    "code": "function Vector (data) {\n  Group.call(this, data)",
    "ctx": {
      "type": "function",
      "name": "Vector",
      "string": "Vector()"
    }
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "{Scalar} result",
        "types": [
          "Scalar"
        ],
        "typesDescription": "<a href=\"Scalar.html\">Scalar</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>result</p>"
      }
    ],
    "description": {
      "full": "<p>Norm of a vector</p><p>Given v = (x1, x2, ... xN)</p><p>norm is defined as n = x1 <em> x1 + x2 </em> x2 + ... + xN * xN</p>",
      "summary": "<p>Norm of a vector</p>",
      "body": "<p>Given v = (x1, x2, ... xN)</p><p>norm is defined as n = x1 <em> x1 + x2 </em> x2 + ... + xN * xN</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 388,
    "codeStart": 398,
    "code": "function vectorNorm () {\n  var result = Scalar.multiplication(data[0], data[0])\n\n  for (var i = 1; i < dimension; i++) {\n    result = Scalar.addition(result, Scalar.multiplication(data[i], data[i]))\n  }\n\n  return new Scalar(result)\n}\n\nObject.defineProperty(this, 'norm', {get: vectorNorm})\n    }\n\n    inherits(Vector, Group)\n\n    Vector.addition = Group.addition\n    Vector.subtraction = Group.subtraction\n    Vector.negation = Group.negation\n\n    Object.defineProperty(Vector, 'zero', {\nwritable: false,\nvalue: zero\n    })\n\n    function crossProduct (right) {\nvar rightData      = toData(right),\n    rightDimension = rightData.length,\n    rightIndices   = getIndices(right)\n\n      // TODO complete cross product\n    }\n\n    // Cross product is defined only in dimension 3.\n    if (dimension === 3) {\nVector.prototype.crossProduct = crossProduct\nVector.prototype.cross        = crossProduct\nVector.prototype.x            = crossProduct\n    }",
    "ctx": {
      "type": "function",
      "name": "vectorNorm",
      "string": "vectorNorm()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 437,
    "codeStart": 441,
    "code": "function matrixProduct (matrix) {\n  var matrixData    = toData(matrix),\n      matrixIndices = getIndices(matrix)\n\n  var indices = [1, dimension]\n\n  var data = rowByColumnMultiplication(Scalar, this.data, indices, matrixData, matrixIndices)\n\n  this.data = data\n\n  return this\n}\n\nVector.prototype.matrixProduct = matrixProduct",
    "ctx": {
      "type": "function",
      "name": "matrixProduct",
      "string": "matrixProduct()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 456,
    "codeStart": 460,
    "code": "function scalarProduct (vector1, vector2) {\n  var vectorData1    = toData(vector1),\n      vectorData2    = toData(vector2)\n\n  if (vectorData1.length !== vectorData2.length)\n    throw new TypeError('Vectors has not the same dimension')\n\n  var result = Scalar.multiplication(vectorData1[0], vectorData2[0])\n\n  for (var i = 1; i < dimension; i++) {\n    result = Scalar.addition(result, Scalar.multiplication(vectorData1[i], vectorData2[i]))\n  }\n\n  return result\n}\n\nfunction vectorScalarProduct (vector) {\n  var result = scalarProduct(this.data, vector)\n\n  return new Scalar(result)\n}\n\nVector.prototype.scalarProduct = vectorScalarProduct\nVector.prototype.dotProduct    = vectorScalarProduct\nVector.prototype.dot           = vectorScalarProduct\n\nfunction perScalarProduct (Scalar) {\n  var data       = this.data,\n      ScalarData = toData(Scalar)\n\n  for (var i = 0; i < dimension; i++)\n    data[i] = Scalar.mul(data[i], ScalarData)\n\n  this.data = data\n\n  return this\n}\n\nVector.prototype.perScalarProduct = perScalarProduct\n\nVector.scalarProduct = scalarProduct\n\nreturn Vector\n  }\n}\n\nmodule.exports = VectorSpace\n\n\nvar inherits = require('inherits')\n\nvar addStaticOperators  = require('./addStaticOperators'),\nbuildFieldOperators = require('./buildFieldOperators'),\nScalar              = require('./Scalar')",
    "ctx": {
      "type": "function",
      "name": "scalarProduct",
      "string": "scalarProduct()"
    }
  },
  {
    "tags": [
      {
        "type": "function",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{Number} n\n",
        "name": "n",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Number} n</p>"
      },
      {
        "type": "returns",
        "string": "{Boolean}",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "",
        "html": "<p>{Boolean}</p>"
      }
    ],
    "description": {
      "full": "<p>Check if a number is prime</p>",
      "summary": "<p>Check if a number is prime</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 515,
    "codeStart": 525,
    "code": "function isPrime (n) {\n  if (n === 1) return false\n  if (n === 2) return true\n\n  var m = Math.sqrt(n)\n\n  for (var i = 2; i <= m; i++)\n    if (n % i === 0)\n      return false\n\n  return true\n}",
    "ctx": {
      "type": "function",
      "name": "isPrime",
      "string": "isPrime()"
    }
  },
  {
    "tags": [
      {
        "type": "function",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{Array} elements\n",
        "name": "elements",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Array} elements</p>"
      },
      {
        "type": "returns",
        "string": "{Boolean}",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "",
        "html": "<p>{Boolean}</p>"
      }
    ],
    "description": {
      "full": "<p>Check if given elements are unique</p>",
      "summary": "<p>Check if given elements are unique</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 538,
    "codeStart": 548,
    "code": "function unique (elements) {\n  for (var i = 0; i < elements.length - 1; i++)\n    for (var j = i + 1; j < elements.length; j++)\n      if (elements[i] === elements[j])\n        return false\n\n  return true\n}",
    "ctx": {
      "type": "function",
      "name": "unique",
      "string": "unique()"
    }
  },
  {
    "tags": [
      {
        "type": "function",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{Array|String} elements\n",
        "name": "elements",
        "description": "",
        "types": [
          "Array",
          "String"
        ],
        "typesDescription": "<code>Array</code>|<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Array|String} elements</p>"
      },
      {
        "type": "returns",
        "string": "{Object} Cyclic",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>Cyclic</p>"
      }
    ],
    "description": {
      "full": "<p>Construct a space isomorphic to Zp: the cyclic group of order p, where p is prime.</p>",
      "summary": "<p>Construct a space isomorphic to Zp: the cyclic group of order p, where p is prime.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 557,
    "codeStart": 567,
    "code": "function buildCyclicSpaceOf (elements) {\n  if ((typeof elements.length !== 'number') || (! isPrime(elements.length)))\n    throw new TypeError(\"elements length must be prime\")\n\n  if ((! unique(elements)))\n    throw new TypeError(\"elements must be unique\")\n\n  var zero = elements[0],\n      one  = elements[1]",
    "ctx": {
      "type": "function",
      "name": "buildCyclicSpaceOf",
      "string": "buildCyclicSpaceOf()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 577,
    "codeStart": 580,
    "code": "function numOf (element) {\n  return elements.indexOf(element)\n}",
    "ctx": {
      "type": "function",
      "name": "numOf",
      "string": "numOf()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 584,
    "codeStart": 587,
    "code": "function addition (element1, element2) {\n  var n = numOf(element1) + numOf(element2)\n\n  n = n % elements.length\n\n  return elements[n]\n}",
    "ctx": {
      "type": "function",
      "name": "addition",
      "string": "addition()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 595,
    "codeStart": 598,
    "code": "function contains (element) {\n  return elements.indexOf(element) > -1\n}",
    "ctx": {
      "type": "function",
      "name": "contains",
      "string": "contains()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 602,
    "codeStart": 605,
    "code": "function multiplication (element1, element2) {\n  var n = numOf(element1) * numOf(element2)\n\n  n = n % elements.length\n\n  return elements[n]\n}",
    "ctx": {
      "type": "function",
      "name": "multiplication",
      "string": "multiplication()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 613,
    "codeStart": 616,
    "code": "function inversion (element) {\n  for (var i = 0; i < elements.length; i++)\n    if(elements[1] == multiplication(element, elements[i]))\n\n  return elements[i]\n}",
    "ctx": {
      "type": "function",
      "name": "inversion",
      "string": "inversion()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 623,
    "codeStart": 626,
    "code": "function division (element1, element2) {\n  return multiplication(element1, inversion(element2))\n}",
    "ctx": {
      "type": "function",
      "name": "division",
      "string": "division()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 630,
    "codeStart": 633,
    "code": "function negation (element) {\n  var n = numOf(element)\n\n  if (n === 0)\n    return element\n\n  n = elements.length - n\n\n  return elements[n]\n}",
    "ctx": {
      "type": "function",
      "name": "negation",
      "string": "negation()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 644,
    "codeStart": 647,
    "code": "function equal (element1, element2) {\n  return element1 === element2\n}\n\nvar operators = {\n  addition      : addition,\n  multiplication: multiplication,\n  negation      : negation,\n  inversion     : inversion,\n  equal         : equal,\n  contains      : contains\n}\n\nvar field = {\n  one     : one,\n  zero    : zero,\n  operator: operators\n}",
    "ctx": {
      "type": "function",
      "name": "equal",
      "string": "equal()"
    }
  },
  {
    "tags": [
      {
        "type": "class",
        "string": "",
        "html": ""
      }
    ],
    "description": {
      "full": "<p>Cyclic element.</p>",
      "summary": "<p>Cyclic element.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": true,
    "isEvent": false,
    "ignore": true,
    "line": 666,
    "codeStart": 672,
    "code": "function Cyclic (data) {\n  Scalar.call(this, field, data)\n}\n\ninherits(Cyclic, Scalar)\n\naddStaticOperators(Cyclic, buildFieldOperators(field))\n\nreturn Cyclic\n}\n\nmodule.exports = buildCyclicSpaceOf\n\n\nvar CayleyDickson = require('./constructCayleyDicksonAlgebra'),\n  ring          = require('./ring')\n\nfunction CayleyDicksonAlgebra (K, iterations) {\nvar Kn = CayleyDickson(K, iterations)\n\nreturn ring([Kn.zero, Kn.one], Kn)\n}\n\nmodule.exports = CayleyDicksonAlgebra\n\n\nvar toData = require('./toData')",
    "ctx": {
      "type": "function",
      "name": "Cyclic",
      "string": "Cyclic()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "string": "private\n",
        "visibility": "private",
        "html": "<p>private</p>"
      },
      {
        "type": "param",
        "string": "{Function} operator\n",
        "name": "operator",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} operator</p>"
      },
      {
        "type": "returns",
        "string": "{Function} anonymous coerced operator",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>anonymous coerced operator</p>"
      }
    ],
    "description": {
      "full": "<p>Get an operator that coerces arguments to data.</p>",
      "summary": "<p>Get an operator that coerces arguments to data.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 700,
    "codeStart": 710,
    "code": "function coerced (operator) {\n  return function () {\n    return operator.apply(null, [].slice.call(arguments).map(toData))\n  }\n}\n\nmodule.exports = coerced",
    "ctx": {
      "type": "function",
      "name": "coerced",
      "string": "coerced()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Function} operator\n",
        "name": "operator",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} operator</p>"
      },
      {
        "type": "returns",
        "string": "{Function} anonymous accessor",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>anonymous accessor</p>"
      }
    ],
    "description": {
      "full": "<p>Comparison operator for group and ring classes</p>",
      "summary": "<p>Comparison operator for group and ring classes</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 719,
    "codeStart": 727,
    "code": "function comparison (operator) {\n  return function () {\n    return operator.bind(null, this.data).apply(null, arguments)\n  }\n}\n\nmodule.exports = comparison\n\n\n//var algebraGroup = require('algebra-group'),\n//    algebraRing  = require('algebra-ring')\nvar ring = require('./ring')\n\nvar twoPow = Math.pow.bind(null, 2)",
    "ctx": {
      "type": "function",
      "name": "comparison",
      "string": "comparison()"
    }
  },
  {
    "tags": [
      {
        "type": "params",
        "string": "{Object} field",
        "html": "<p>{Object} field</p>"
      },
      {
        "type": "params",
        "string": "{Number} iterations ",
        "html": "<p>{Number} iterations </p>"
      },
      {
        "type": "returns",
        "string": "{Object} algebra",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>algebra</p>"
      }
    ],
    "description": {
      "full": "<p>Iterate Cayley-Disckson construction</p>",
      "summary": "<p>Iterate Cayley-Disckson construction</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 742,
    "codeStart": 751,
    "code": "function constructCayleyDicksonAlgebra (field, iterations) {\n  if (! (iterations in {0: 'real', 1: 'complex', 2: 'quaternion', 3: 'octonion'}))\n    throw new TypeError('Num of iterations must be 1, 2 or 3')\n\n  if (iterations === 0)\n    return field\n\n  // identities\n\n  var one  = [],\n      zero = [],\n      dim  = twoPow(iterations)\n\n  one.push(field.one)\n  zero.push(field.zero)\n\n  for (var i = 1; i < dim; i++) {\n    one.push(field.zero)\n    zero.push(field.zero)\n  }\n\n  // operators\n\n  function equality (a, b) {\n    for (var i = 0; i < dim; i++)\n      if (field.disequality(a[i], b[i]))\n        return false\n\n    return true\n  }\n\n  function contains (a) {\n    for (var i = 0; i < dim; i++)\n      if (field.notContains(a[i]))\n        return false\n\n    return true\n  }",
    "ctx": {
      "type": "function",
      "name": "constructCayleyDicksonAlgebra",
      "string": "constructCayleyDicksonAlgebra()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Turn unary operator on single value to operator on n values.</p>",
      "summary": "<p>Turn unary operator on single value to operator on n values.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 790,
    "codeStart": 794,
    "code": "function arrayfy1 (operator, dim) {\n   return function (a) {\n     if (dim === 1)\n       return [operator(a)]\n\n     var b = []\n\n     for (var i = 0; i < dim; i++)\n       b.push(operator(a[i]))\n\n     return b\n   }\n}",
    "ctx": {
      "type": "function",
      "name": "arrayfy1",
      "string": "arrayfy1()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Turn binary operator on single value to operator on n values.</p>",
      "summary": "<p>Turn binary operator on single value to operator on n values.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 808,
    "codeStart": 812,
    "code": "function arrayfy2 (operator, dim) {\n   return function (a, b) {\n     if (dim === 1)\n       return [operator(a, b)]\n\n     var c = []\n\n     for (var i = 0; i < dim; i++)\n       c.push(operator(a[i], b[i]))\n\n     return c\n   }\n}\n\n function buildConjugation (fieldNegation, iterations) {\n   var dim = twoPow(iterations)\n\n   if (dim === 1)\n     return function (b) { return b[0] }\n\n   // b -> p looks like complex conjugation simmetry (:\n   function conjugation (b) {\n     var p = [],\n         halfDim = twoPow(iterations - 1),\n         i = 0\n\n     // First, copy half of b into q.\n     for (i = 0; i < halfDim; i++)\n       p.push(b[i])\n\n     // Then conjugate b, according to lower algebra conjugation.\n     // Note that if iterations - 1 == 0 it is the identity.\n     p = buildConjugation(fieldNegation, iterations - 1)(b)\n\n     for (i = halfDim; i < dim; i++)\n       p.push(fieldNegation(b[i]))\n\n     return p\n   }\n\n   return conjugation\n }\n\n var conjugation = buildConjugation(field.negation, iterations)\n\n function norm (a) {\n   var n       = field.zero,\n       squares = multiplication(a, conjugation(a))\n\n   for (var i = 0; i < dim; i++)\n     n = field.addition(n, squares[i])\n\n   return n\n }\n\n function buildMultiplication (field, iterations) {\n   var dim     = twoPow(iterations),\n       halfDim = 1\n\n   if (iterations === 0)\n     return field.multiplication\n   else\n     halfDim = twoPow(iterations - 1)\n\n   var add  = arrayfy2(field.addition, halfDim),\n       conj = buildConjugation(field.negation, iterations -1),\n       mul  = buildMultiplication(field, iterations - 1),\n       neg  = arrayfy1(field.negation, halfDim)\n\n   function multiplication (a, b) {\n     var c = [],\n         i = 0\n\n     //         a = (p, q)\n     //         b = (r, s)\n     //\n     // a + b = c = (t, u)\n\n     var p = [], q = [],\n         r = [], s = []\n\n     for (i = 0; i < halfDim; i++) {\n       p.push(a[i])\n       r.push(b[i])\n     }\n\n     for (i = halfDim; i < dim; i++) {\n       q.push(a[i])\n       s.push(b[i])\n     }\n\n     // let denote conj(x) as x`\n     //\n     // Multiplication law is given by\n     //\n     // (p, q)(r, s) = (pr - s`q, sp + qr`)\n\n     var t = add(mul(p, r), neg(mul(conj(s), q))),\n         u = add(mul(s, p), mul(q, conj(r)))\n\n     for (i = 0; i < halfDim; i++)\n       c.push(t[i])\n\n     for (i = halfDim; i < dim; i++)\n       c.push(u[i])\n\n     return c\n   }\n\n   return multiplication\n }\n\n var multiplication = buildMultiplication(field, iterations)\n\n function inversion (a) {\n   var n = norm(a)\n\n   var b = conjugation(a)\n\n   for (var i = 0; i < dim; i++)\n     b[i] = field.division(b[i], n)\n\n   return b\n }\n\n var addition = arrayfy2(field.addition, dim),\n     negation = arrayfy1(field.negation, dim)\n\n var algebra = ring([zero, one], {\n   contains       : contains,\n   equality       : equality,\n   addition       : addition,\n   negation       : negation,\n   multiplication : multiplication,\n   inversion      : inversion\n })\n\n algebra.conjugation = conjugation\n algebra.norm        = norm\n\n return algebra\n}\n\nmodule.exports = constructCayleyDicksonAlgebra\n\n\nvar matrixToArrayIndex = require('./matrixToArrayIndex'),\n   subMatrix          = require('./subMatrix')",
    "ctx": {
      "type": "function",
      "name": "arrayfy2",
      "string": "arrayfy2()"
    }
  },
  {
    "tags": [
      {
        "type": "function",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{Object} scalar",
        "name": "scalar",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Object} scalar</p>"
      },
      {
        "type": "param",
        "string": "{Function} scalar.addition",
        "name": "scalar.addition",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} scalar.addition</p>"
      },
      {
        "type": "param",
        "string": "{Function} scalar.multiplication",
        "name": "scalar.multiplication",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} scalar.multiplication</p>"
      },
      {
        "type": "param",
        "string": "{Function} scalar.negation",
        "name": "scalar.negation",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} scalar.negation</p>"
      },
      {
        "type": "param",
        "string": "{Array} data",
        "name": "data",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Array} data</p>"
      },
      {
        "type": "param",
        "string": "{Number} order\n",
        "name": "order",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Number} order</p>"
      },
      {
        "type": "returns",
        "string": "{Any} det",
        "types": [
          "Any"
        ],
        "typesDescription": "<a href=\"Any.html\">Any</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>det</p>"
      }
    ],
    "description": {
      "full": "<p>Computes the determinant of a matrix using Laplace&#39;s formula</p><p>See <a href=\"https://en.wikipedia.org/wiki/Laplace_expansion\">https://en.wikipedia.org/wiki/Laplace_expansion</a></p>",
      "summary": "<p>Computes the determinant of a matrix using Laplace&#39;s formula</p>",
      "body": "<p>See <a href=\"https://en.wikipedia.org/wiki/Laplace_expansion\">https://en.wikipedia.org/wiki/Laplace_expansion</a></p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 961,
    "codeStart": 978,
    "code": "function determinant (scalar, data, order) {\n  var det,\n      add = scalar.addition,\n      mul = scalar.multiplication,\n      neg = scalar.negation\n\n  // Recursion will stop here:\n  // the determinant of a 1x1 matrix is its only element.\n  if (order === 1)\n    return data[0]\n\n  // TODO choose best row or column to start from, i.e. the one with more zeros\n  // by now we start from first row, and walk by column\n  // needs scalar.isZero\n  var startingCol = 0,\n      startingRow = 0\n\n  for (var col = 0; col < order; col++) {\n    var subData = subMatrix(data, order, order, startingRow, col)\n\n                // +-- Recursion here.\n                // ↓\n    var cofactor = determinant(scalar, subData, order - 1)\n\n    if ((startingRow + col) % 2 === 1)\n      cofactor = neg(cofactor)\n\n    var index = matrixToArrayIndex(startingRow, col, order)\n\n    if (typeof det === 'undefined')\n      det = mul(data[index], cofactor) // first iteration\n    else\n      det = add(det, mul(data[index], cofactor))\n  }\n\n  return det\n}\n\nmodule.exports = determinant\n\n\nvar toData = require('./toData')",
    "ctx": {
      "type": "function",
      "name": "determinant",
      "string": "determinant()"
    }
  },
  {
    "tags": [
      {
        "type": "function",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{Array|Any} arg\n",
        "name": "arg",
        "description": "",
        "types": [
          "Array",
          "Any"
        ],
        "typesDescription": "<code>Array</code>|<a href=\"Any.html\">Any</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Array|Any} arg</p>"
      },
      {
        "type": "return",
        "string": "{Array} indices",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>indices</p>"
      }
    ],
    "description": {
      "full": "<p>Extract indices attribute, if any</p>",
      "summary": "<p>Extract indices attribute, if any</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 1021,
    "codeStart": 1031,
    "code": "function getIndices (arg) {\n  var indices\n\n  if (typeof arg.indices === 'undefined') {\n// TODO\n//   var data = toData(arg)\n//\n//   if (typeof data === 'array') {\n//     // TODO recursion into data if it is a multidimensional array\n//     indices = [data.length]\n//   }\n//   else {\n//     indices = [1]\n//   }\n  }\n  else {\n    indices = arg.indices\n  }\n\n  if (typeof indices === 'undefined')\n    throw new TypeError('No indices')\n\n  return indices\n}\n\nmodule.exports = getIndices\n\n\nvar algebraGroup = require('algebra-group'),\n    coerced      = require('./coerced'),\n    comparison   = require('./comparison'),\n    Element      = require('./Element'),\n    mutator      = require('./mutator'),\n    inherits     = require('inherits')\n\nvar nAryMutator  = mutator.nAry,\n    unaryMutator = mutator.unary",
    "ctx": {
      "type": "function",
      "name": "getIndices",
      "string": "getIndices()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} given",
        "name": "given",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Object} given</p>"
      },
      {
        "type": "param",
        "string": "{*}        given.identity a.k.a neutral element",
        "name": "given.identity",
        "description": "<p>a.k.a neutral element</p>",
        "types": [],
        "typesDescription": "<code>*</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} given.contains",
        "name": "given.contains",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} given.contains</p>"
      },
      {
        "type": "param",
        "string": "{Function} given.equality",
        "name": "given.equality",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} given.equality</p>"
      },
      {
        "type": "param",
        "string": "{Function} given.compositionLaw",
        "name": "given.compositionLaw",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} given.compositionLaw</p>"
      },
      {
        "type": "param",
        "string": "{Function} given.inversion",
        "name": "given.inversion",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} given.inversion</p>"
      },
      {
        "type": "param",
        "string": "{Object} [naming]",
        "name": "[naming]",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Object} [naming]</p>"
      },
      {
        "type": "param",
        "string": "{String} [naming.identity=zero]",
        "name": "[naming.identity=zero]",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{String} [naming.identity=zero]</p>"
      },
      {
        "type": "param",
        "string": "{String} [naming.contains=contains]",
        "name": "[naming.contains=contains]",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{String} [naming.contains=contains]</p>"
      },
      {
        "type": "param",
        "string": "{String} [naming.equality=equality]",
        "name": "[naming.equality=equality]",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{String} [naming.equality=equality]</p>"
      },
      {
        "type": "param",
        "string": "{String} [naming.compositionLaw=addition]",
        "name": "[naming.compositionLaw=addition]",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{String} [naming.compositionLaw=addition]</p>"
      },
      {
        "type": "param",
        "string": "{String} [naming.inversion=negation]",
        "name": "[naming.inversion=negation]",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{String} [naming.inversion=negation]</p>"
      },
      {
        "type": "param",
        "string": "{String} [naming.inverseCompositionLaw=subtraction]",
        "name": "[naming.inverseCompositionLaw=subtraction]",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{String} [naming.inverseCompositionLaw=subtraction]</p>"
      },
      {
        "type": "param",
        "string": "{String} [naming.notContains=notContains]\n",
        "name": "[naming.notContains=notContains]",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{String} [naming.notContains=notContains]</p>"
      },
      {
        "type": "returns",
        "string": "{Function} Group that implements an algebra group as a class",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>Group that implements an algebra group as a class</p>"
      }
    ],
    "description": {
      "full": "<p>Create an algebra group.</p>",
      "summary": "<p>Create an algebra group.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1069,
    "codeStart": 1090,
    "code": "function group (given, naming) {\n  var g = algebraGroup(given, naming)\n\n  function Group (data) {\n    Element.call(this, data, given.contains)\n  }\n\n  inherits(Group, Element)\n\n  var addition    = coerced(g.addition),\n      contains    = coerced(g.contains),\n      disequality = coerced(g.disequality),\n      equality    = coerced(g.equality),\n      negation    = coerced(g.negation),\n      notContains = coerced(g.notContains),\n      subtraction = coerced(g.subtraction)\n\n  // Comparison operators.\n\n  Group.prototype.equality    = comparison(equality)\n  Group.prototype.disequality = comparison(disequality)\n\n  // Chainable class methods.\n\n  Group.prototype.addition    = nAryMutator(addition)\n  Group.prototype.subtraction = nAryMutator(subtraction)\n  Group.prototype.negation    = unaryMutator(negation)\n\n  // Static operators.\n\n  Group.addition       = addition\n  Group.contains       = contains\n  Group.disequality    = disequality\n  Group.equality       = equality\n  Group.negation       = negation\n  Group.notContains    = notContains\n  Group.subtraction    = subtraction\n\n  // Identity.\n\n  Object.defineProperty(Group, 'zero', {\n    writable: false,\n    value: g.zero\n  })\n\n  // Aliases.\n\n  Group.eq = Group.equality\n  Group.ne = Group.disequality\n\n  Group.equal    = Group.equality\n  Group.notEqual = Group.disequality\n  Group.notEq    = Group.disequality\n\n  Group.add = Group.addition\n  Group.neg = Group.negation\n  Group.sub = Group.subtraction\n\n  Group.prototype.add = Group.prototype.addition\n  Group.prototype.neg = Group.prototype.negation\n  Group.prototype.sub = Group.prototype.subtraction\n\n  return Group\n}\n\nmodule.exports = group",
    "ctx": {
      "type": "function",
      "name": "group",
      "string": "group()"
    }
  },
  {
    "tags": [
      {
        "type": "function",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{Number} i index row",
        "name": "i",
        "description": "<p>index row</p>",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} j index column",
        "name": "j",
        "description": "<p>index column</p>",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} numCols\n",
        "name": "numCols",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Number} numCols</p>"
      },
      {
        "type": "returns",
        "string": "{Number} index",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>index</p>"
      }
    ],
    "description": {
      "full": "<p>Convert a pair of indices to a 1-dimensional index</p>",
      "summary": "<p>Convert a pair of indices to a 1-dimensional index</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1158,
    "codeStart": 1169,
    "code": "function matrixToArrayIndex (i, j, numCols) {\n  return j + i * numCols\n}\n\nmodule.exports = matrixToArrayIndex\n\n\nfunction unaryMutator (operator) {\n  return function () {\n    this.data = operator(this.data)\n    return this\n  }\n}\n\nexports.unary = unaryMutator\n\nfunction nAryMutator (operator) {\n  return function () {\n    this.data = operator.bind(null, this.data).apply(null, arguments)\n    return this\n  }\n}\n\nexports.nAry = nAryMutator\n\n\nvar zero = 0,\n    one  = 1",
    "ctx": {
      "type": "function",
      "name": "matrixToArrayIndex",
      "string": "matrixToArrayIndex()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 1198,
    "codeStart": 1201,
    "code": "function addition (a, b) { return a + b }",
    "ctx": {
      "type": "function",
      "name": "addition",
      "string": "addition()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 1203,
    "codeStart": 1206,
    "code": "function multiplication (a, b) { return a * b }",
    "ctx": {
      "type": "function",
      "name": "multiplication",
      "string": "multiplication()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 1208,
    "codeStart": 1211,
    "code": "function inversion (a) { return one / a }",
    "ctx": {
      "type": "function",
      "name": "inversion",
      "string": "inversion()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 1213,
    "codeStart": 1216,
    "code": "function negation (a) { return - a }",
    "ctx": {
      "type": "function",
      "name": "negation",
      "string": "negation()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 1218,
    "codeStart": 1221,
    "code": "function equal (a, b) { return a === b }",
    "ctx": {
      "type": "function",
      "name": "equal",
      "string": "equal()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 1223,
    "codeStart": 1226,
    "code": "function contains (a) {\n  // NaN, Infinity and -Infinity are not allowed\n  return (typeof a === 'number' && isFinite(a))\n}\n\nvar operators = {\n  addition      : addition,\n  multiplication: multiplication,\n  negation      : negation,\n  inversion     : inversion,\n  equal         : equal,\n  contains      : contains\n}\n\nvar realField = {\n  one     : one,\n  zero    : zero,\n  operator: operators\n}\n\nmodule.exports = realField\n\n\nvar algebraRing = require('algebra-ring'),\n    coerced     = require('./coerced'),\n    comparison  = require('./comparison'),\n    Element     = require('./Element'),\n    mutator     = require('./mutator'),\n    inherits    = require('inherits')\n\nvar nAryMutator  = mutator.nAry,\n    unaryMutator = mutator.unary",
    "ctx": {
      "type": "function",
      "name": "contains",
      "string": "contains()"
    }
  },
  {
    "tags": [
      {
        "type": "params",
        "string": "{Array} identity",
        "html": "<p>{Array} identity</p>"
      },
      {
        "type": "params",
        "string": "{Array} identity[0] a.k.a. zero",
        "html": "<p>{Array} identity[0] a.k.a. zero</p>"
      },
      {
        "type": "params",
        "string": "{Array} identity[1] a.k.a. uno",
        "html": "<p>{Array} identity[1] a.k.a. uno</p>"
      },
      {
        "type": "params",
        "string": "{Object} given operator functions",
        "html": "<p>{Object} given operator functions</p>"
      },
      {
        "type": "param",
        "string": "{Function} given.contains",
        "name": "given.contains",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} given.contains</p>"
      },
      {
        "type": "param",
        "string": "{Function} given.equality",
        "name": "given.equality",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} given.equality</p>"
      },
      {
        "type": "param",
        "string": "{Function} given.addition",
        "name": "given.addition",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} given.addition</p>"
      },
      {
        "type": "param",
        "string": "{Function} given.negation",
        "name": "given.negation",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} given.negation</p>"
      },
      {
        "type": "param",
        "string": "{Function} given.multiplication",
        "name": "given.multiplication",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} given.multiplication</p>"
      },
      {
        "type": "param",
        "string": "{Function} given.inversion\n",
        "name": "given.inversion",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} given.inversion</p>"
      },
      {
        "type": "returns",
        "string": "{Function} Ring that implements an algebra ring as a class",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>Ring that implements an algebra ring as a class</p>"
      }
    ],
    "description": {
      "full": "<p>Create an algebra ring.</p>",
      "summary": "<p>Create an algebra ring.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1259,
    "codeStart": 1276,
    "code": "function ring (identity, given) {\n  var r = algebraRing(identity, given)\n\n  function Ring (data) {\n    Element.call(this, data, given.contains)\n  }\n\n  inherits(Ring, Element)\n\n  // Note that many code in ring.js is almost the same of group.js:\n  // copy and paste over inheritance!\n\n  var addition    = coerced(r.addition),\n      contains    = coerced(r.contains),\n      disequality = coerced(r.disequality),\n      equality    = coerced(r.equality),\n      negation    = coerced(r.negation),\n      notContains = coerced(r.notContains),\n      subtraction = coerced(r.subtraction)\n\n  var multiplication = coerced(r.multiplication),\n      division       = coerced(r.division),\n      inversion      = coerced(r.inversion)\n\n  // Comparison operators.\n\n  Ring.prototype.equality    = comparison(equality)\n  Ring.prototype.disequality = comparison(disequality)\n\n  // Chainable class methods.\n\n  Ring.prototype.addition    = nAryMutator(addition)\n  Ring.prototype.subtraction = nAryMutator(subtraction)\n  Ring.prototype.negation    = unaryMutator(negation)\n\n  Ring.prototype.multiplication = nAryMutator(multiplication)\n  Ring.prototype.division       = nAryMutator(division)\n  Ring.prototype.inversion      = unaryMutator(r.inversion)\n\n  // Static operators.\n\n  Ring.addition    = addition\n  Ring.contains    = contains\n  Ring.disequality = disequality\n  Ring.equality    = equality\n  Ring.negation    = negation\n  Ring.notContains = notContains\n  Ring.subtraction = subtraction\n\n  Ring.multiplication = multiplication\n  Ring.division       = division\n  Ring.inversion      = inversion\n\n  // Aliases.\n\n  Ring.eq = Ring.equality\n  Ring.ne = Ring.disequality\n\n  Ring.equal    = Ring.equality\n  Ring.notEqual = Ring.disequality\n  Ring.notEq    = Ring.disequality\n\n  Ring.add = Ring.addition\n  Ring.neg = Ring.negation\n  Ring.sub = Ring.subtraction\n\n  Ring.div = Ring.division\n  Ring.inv = Ring.inversion\n  Ring.mul = Ring.multiplication\n\n  Ring.prototype.add = Ring.prototype.addition\n  Ring.prototype.neg = Ring.prototype.negation\n  Ring.prototype.sub = Ring.prototype.subtraction\n\n  Ring.prototype.mul = Ring.prototype.multiplication\n  Ring.prototype.div = Ring.prototype.division\n  Ring.prototype.inv = Ring.prototype.inversion\n\n  // Identities.\n\n  Object.defineProperties(Ring, {\n    'zero': {\n      writable: false,\n      value: identity[0]\n    },\n    'one': {\n      writable: false,\n      value: identity[1]\n    }\n  })\n\n  return Ring\n}\n\nmodule.exports = ring\n\n\nvar matrixToArrayIndex = require('./matrixToArrayIndex')",
    "ctx": {
      "type": "function",
      "name": "ring",
      "string": "ring()"
    }
  },
  {
    "tags": [
      {
        "type": "function",
        "string": "",
        "html": ""
      },
      {
        "type": "api",
        "string": "private\n",
        "visibility": "private",
        "html": "<p>private</p>"
      },
      {
        "type": "param",
        "string": "{Object}   scalar",
        "name": "scalar",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Object}   scalar</p>"
      },
      {
        "type": "param",
        "string": "{Function} scalar.addition",
        "name": "scalar.addition",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} scalar.addition</p>"
      },
      {
        "type": "param",
        "string": "{Function} scalar.multiplication",
        "name": "scalar.multiplication",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Function} scalar.multiplication</p>"
      },
      {
        "type": "param",
        "string": "{Array} leftMatrix",
        "name": "leftMatrix",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Array} leftMatrix</p>"
      },
      {
        "type": "param",
        "string": "{Array} leftIndices",
        "name": "leftIndices",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Array} leftIndices</p>"
      },
      {
        "type": "param",
        "string": "{Array} rightMatrix",
        "name": "rightMatrix",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Array} rightMatrix</p>"
      },
      {
        "type": "param",
        "string": "{Array} rightIndices\n",
        "name": "rightIndices",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Array} rightIndices</p>"
      },
      {
        "type": "returns",
        "string": "{Array} data",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>data</p>"
      }
    ],
    "description": {
      "full": "<p>Multiply two matrices, row by column.</p>",
      "summary": "<p>Multiply two matrices, row by column.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1375,
    "codeStart": 1393,
    "code": "function rowByColumnMultiplication (scalar, leftMatrix, leftIndices, rightMatrix, rightIndices) {\n  // Check if matrices can be multiplied.\n  if (leftIndices[1] !== rightIndices[0])\n    throw new TypeError('Left num cols != right num rows')\n\n  var commonIndex = leftIndices[1],\n      data        = [],\n      rows        = leftIndices[0],\n      cols        = rightIndices[1]\n\n  for (var i = 0; i < rows; i++) {\n    for (var j = 0; j < cols; j++) {\n      var leftIndex  = matrixToArrayIndex(i, 0, commonIndex),\n          rightIndex = matrixToArrayIndex(0, j, cols)\n\n      var rightElement = rightMatrix[rightIndex],\n          leftElement  = leftMatrix[leftIndex]\n\n      var element = scalar.multiplication(leftElement, rightElement)\n\n      for (var k = 1; k < commonIndex; k++) {\n        leftIndex = matrixToArrayIndex(i, k, commonIndex)\n        rightIndex = matrixToArrayIndex(k, j, cols)\n\n        rightElement = rightMatrix[rightIndex]\n        leftElement = leftMatrix[leftIndex]\n\n        element = scalar.addition(element, scalar.multiplication(rightElement, leftElement))\n      }\n\n      data.push(element)\n    }\n  }\n\n  return data\n}\n\nmodule.exports = rowByColumnMultiplication\n\n\nvar matrixToArrayIndex = require('./matrixToArrayIndex')",
    "ctx": {
      "type": "function",
      "name": "rowByColumnMultiplication",
      "string": "rowByColumnMultiplication()"
    }
  },
  {
    "tags": [
      {
        "type": "function",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{Array} data set",
        "name": "data",
        "description": "<p>set</p>",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} numRows",
        "name": "numRows",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Number} numRows</p>"
      },
      {
        "type": "param",
        "string": "{Number} numCols",
        "name": "numCols",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{Number} numCols</p>"
      },
      {
        "type": "param",
        "string": "{Number} row index deleted",
        "name": "row",
        "description": "<p>index deleted</p>",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} col index deleted\n",
        "name": "col",
        "description": "<p>index deleted </p>",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Array} sub data-set",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>sub data-set</p>"
      }
    ],
    "description": {
      "full": "<p>Compute the sub-matrix formed by deleting the i-th row and j-th column</p>",
      "summary": "<p>Compute the sub-matrix formed by deleting the i-th row and j-th column</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1435,
    "codeStart": 1449,
    "code": "function subMatrix (data, numRows, numCols, row, col) {\n  var sub = []\n\n  for (var i = 0; i < numRows; i++)\n    for (var j = 0; j < numCols; j++)\n      if ((i !== row) && (j !== col))\n        sub.push(data[matrixToArrayIndex(i, j, numCols)])\n\n  return sub\n}\n\nmodule.exports = subMatrix",
    "ctx": {
      "type": "function",
      "name": "subMatrix",
      "string": "subMatrix()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "string": "private\n",
        "visibility": "private",
        "html": "<p>private</p>"
      },
      {
        "type": "param",
        "string": "{*} arg\n",
        "name": "arg",
        "description": "",
        "types": [],
        "typesDescription": "<code>*</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{*} arg</p>"
      },
      {
        "type": "returns",
        "string": "{*} data",
        "types": [],
        "typesDescription": "<code>*</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>data</p>"
      }
    ],
    "description": {
      "full": "<p>Extract data attribute, if any, and check it</p>",
      "summary": "<p>Extract data attribute, if any, and check it</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1463,
    "codeStart": 1473,
    "code": "function toData (arg) {\n  var data\n\n  if (typeof arg.data === 'undefined')\n    data = arg\n  else\n    data = arg.data\n\n  if (typeof data === 'undefined')\n    throw new TypeError('No data')\n\n  return data\n}\n\nmodule.exports = toData",
    "ctx": {
      "type": "function",
      "name": "toData",
      "string": "toData()"
    }
  }
]